+ 秒杀

+ 分析秒杀的业务

+ 实现秒杀的功能

+ 实现秒杀的功能的整体的思路()
	+ 定时任务(sprring task)

	+ 多线程()

	+ 队列

	+ rabbitmq (延时队列)

	+ 支付(携带额外参数)

	+ 限流	  (....)

	+ 网页静态化(....)

 + 秒杀商品的列表展示  详情的展示

 + 实现普通的下单操作.









 + 秒杀
	+ 库存有限 
	+ 时间有限

	+ 业务:
		+ 每一个用户一次性只能买一个商品
		+ 需要先支付 在进行地址的填写
		+ 只有支付之后,才能继续购买.

		+ 如果当前时间在活动时间之外,不能秒杀

		+ 库存如果为0 也不能秒杀.




+秒杀 
	+ 高并发     思想就是限流.
	
	+ 可以使用redis 来进行数据的存储 和读取.(避免读取和写入数据库)





+ 通过定时任务  查询符合条件的数据 到Redis中

	+ spring task

		+ 1.启用Schedule(注解)
		+ 2.创建一个类(任务) 交给spring 容器
		+ 3.任务类中写一个方法 (就是一个任务) 指定一个注解(计划注解)来执行,指定CROn表达式.




	+ 24小时 换成  12个时间段   


		每一个时间段 ---> 对应一部分的数据



		redis存储:hash类型
			key(时间段:2019090516)     field (id:1)   value(商品的数据pojo)

						   field (id:2)   value(商品的数据pojo)

			key(时间段:2019090518)     field (id:3)   value(商品的数据pojo)

						   field (id:4)   value(商品的数据pojo)



		        

		数据存储到redis中的条件是什么?
		select * from tb_seckill_goods where stock_count>0 
		and `status`='1' 
		and start_time > 开始时间段 
		and end_time < 开始时间段+2hour





		+ 把 当前的时间 换成 5个时间段,循环遍历12个时间段,获取到每一个时间段的yyymmddhh 做为条件 
		+ 去数据库进行查询

		+ 将符合条件的数据存储到redis 中  
		
+ redis的序列化
	+ 数据存储到的时候redistemplate 就是将数据进行序列化(key,value 都需要实现seaerialbe接口)成二进制数据

	+ 可以自定义序列化机制(默认是采用jdk自带的)


+ 频道首页 
	+ 需要展示以当前时间为基准的5个时间段
		请求:  /menus
		参数:  没有
		返回值:以当前时间为进准的5个时间段  List<Date>
	+ 展示当前时间的时间段对应的所有的秒杀商品的集合列表
		根据时间段 拼接成年月日小时的格式的字符串作为参数传递后台
		后台接收,从redis中获取到集合展示

		请求:/list
		参数:时间段的字符串 time 2019090516
		返回值:List<seckillgoods>


+商品的详情
	+ 根据点击到的秒杀商品的ID 和 时间段的字符串
	+ 发送请求给后台
	+ 后台接收到之后,从redis中根据key 和field 查询该商品的数据返回
	请求:/one
	参数:time  秒杀商品的id(id)

	返回值:秒杀商品对象


+ 抢购商品
	+ 点击抢购的时候 传递 要购买的商品 id
	+ 传递 时间段
	+ 当前登录的用户名  (后台获取)
	+ 后台接收
		+ 判断是否库存为0
		+ 创建(redis中的预)订单
		+ 减库存
		+ 判断库存是否为0 更新到数据库中,删除掉redis中的该商品
		+ 提交成功

+ 多线程排队处理订单
	+ 使用spring提供的线程池.
	+ 1.开启线程池
	+ 2.定义一个类(写一个方法)方法上,修饰一个注解@Async	 类交给spring容器管理
	+ 3.下单的调用该方法就是多线程的调用了


+ 下单之后 用户需要主动查询他的订单的状态

	请求:/query
	参数:useranme  (controller中获取当前登录的用户的用户名)
	返回值:	result<seckillStatus>


	

